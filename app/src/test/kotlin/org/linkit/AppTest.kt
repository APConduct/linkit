/*
 * This source file was generated by the Gradle 'init' task
 */
@file:Suppress("UNRESOLVED_REFERENCE")

package org.linkit

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class AppTest {

    private val calc = Calc()

    @Test
    fun testBasicArithmetic() {
        // Test: 2 + 3
        val addExpr = Expr.BinaryOp(Expr.Number(2.0), Operation.Binary.Add, Expr.Number(3.0))
        assertEquals(5.0, calc.eval(addExpr), 0.0001)

        // Test: 10 - 4
        val subtractExpr =
                Expr.BinaryOp(Expr.Number(10.0), Operation.Binary.Subtract, Expr.Number(4.0))
        assertEquals(6.0, calc.eval(subtractExpr), 0.0001)

        // Test: 3 * 4
        val multiplyExpr =
                Expr.BinaryOp(Expr.Number(3.0), Operation.Binary.Multiply, Expr.Number(4.0))
        assertEquals(12.0, calc.eval(multiplyExpr), 0.0001)

        // Test: 8 / 2
        val divideExpr = Expr.BinaryOp(Expr.Number(8.0), Operation.Binary.Divide, Expr.Number(2.0))
        assertEquals(4.0, calc.eval(divideExpr), 0.0001)
    }

    @Test
    fun testOrderOfOperations() {
        // Test: 2 + 3 * 4 = 14 (not 20)
        val expr =
                Expr.BinaryOp(
                        Expr.Number(2.0),
                        Operation.Binary.Add,
                        Expr.BinaryOp(Expr.Number(3.0), Operation.Binary.Multiply, Expr.Number(4.0))
                )
        assertEquals(14.0, calc.eval(expr), 0.0001)
    }

    @Test
    fun testUnaryOperations() {
        // Test: sqrt(16)
        val sqrtExpr = Expr.UnaryOp(Operation.Unary.Sqrt, Expr.Number(16.0))
        assertEquals(4.0, calc.eval(sqrtExpr), 0.0001)

        // Test: -5
        val negateExpr = Expr.UnaryOp(Operation.Unary.Negate, Expr.Number(5.0))
        assertEquals(-5.0, calc.eval(negateExpr), 0.0001)

        // Test: abs(-3)
        val absExpr = Expr.UnaryOp(Operation.Unary.Abs, Expr.Number(-3.0))
        assertEquals(3.0, calc.eval(absExpr), 0.0001)
    }

    @Test
    fun testConstants() {
        // Test PI constant
        val piExpr = Expr.Variable("PI")
        assertEquals(kotlin.math.PI, calc.eval(piExpr), 0.0001)

        // Test E constant
        val eExpr = Expr.Variable("E")
        assertEquals(kotlin.math.E, calc.eval(eExpr), 0.0001)
    }

    @Test
    fun testTrigonometry() {
        // Test: sin(PI/2) = 1
        val sinExpr =
                Expr.UnaryOp(
                        Operation.Unary.Sin,
                        Expr.BinaryOp(
                                Expr.Variable("PI"),
                                Operation.Binary.Divide,
                                Expr.Number(2.0)
                        )
                )
        assertEquals(1.0, calc.eval(sinExpr), 0.0001)

        // Test: cos(0) = 1
        val cosExpr = Expr.UnaryOp(Operation.Unary.Cos, Expr.Number(0.0))
        assertEquals(1.0, calc.eval(cosExpr), 0.0001)
    }

    @Test
    fun testDivisionByZero() {
        val divideByZeroExpr =
                Expr.BinaryOp(Expr.Number(5.0), Operation.Binary.Divide, Expr.Number(0.0))

        val exception =
                assertThrows(ArithmeticException::class.java) { calc.eval(divideByZeroExpr) }
        assertEquals("Division by zero", exception.message)
    }

    @Test
    fun testSqrtOfNegative() {
        val sqrtNegativeExpr = Expr.UnaryOp(Operation.Unary.Sqrt, Expr.Number(-4.0))

        val exception =
                assertThrows(ArithmeticException::class.java) { calc.eval(sqrtNegativeExpr) }
        assertEquals("Square root of negative number", exception.message)
    }

    @Test
    fun testUnknownVariable() {
        val unknownVarExpr = Expr.Variable("UNKNOWN")

        val exception =
                assertThrows(IllegalArgumentException::class.java) { calc.eval(unknownVarExpr) }
        assertEquals("Unknown variable: UNKNOWN", exception.message)
    }

    @Test
    fun testParserBasicArithmetic() {
        val parser = Parser()

        // Test: 2 + 3
        val expr1 = parser.parse("2 + 3")
        assertEquals(5.0, calc.eval(expr1), 0.0001)

        // Test: 10 - 4
        val expr2 = parser.parse("10 - 4")
        assertEquals(6.0, calc.eval(expr2), 0.0001)

        // Test: 3 * 4
        val expr3 = parser.parse("3 * 4")
        assertEquals(12.0, calc.eval(expr3), 0.0001)

        // Test: 8 / 2
        val expr4 = parser.parse("8 / 2")
        assertEquals(4.0, calc.eval(expr4), 0.0001)
    }

    @Test
    fun testParserOrderOfOperations() {
        val parser = Parser()

        // Test: 2 + 3 * 4 = 14 (not 20)
        val expr = parser.parse("2 + 3 * 4")
        assertEquals(14.0, calc.eval(expr), 0.0001)

        // Test: (2 + 3) * 4 = 20
        val expr2 = parser.parse("(2 + 3) * 4")
        assertEquals(20.0, calc.eval(expr2), 0.0001)
    }

    @Test
    fun testParserFunctions() {
        val parser = Parser()

        // Test: sqrt(16)
        val expr1 = parser.parse("sqrt(16)")
        assertEquals(4.0, calc.eval(expr1), 0.0001)

        // Test: sin(PI/2)
        val expr2 = parser.parse("sin(PI/2)")
        assertEquals(1.0, calc.eval(expr2), 0.0001)

        // Test: abs(-5)
        val expr3 = parser.parse("abs(-5)")
        assertEquals(5.0, calc.eval(expr3), 0.0001)
    }

    @Test
    fun testParserComplexExpressions() {
        val parser = Parser()

        // Test: sqrt(16) + sin(PI/2)
        val expr = parser.parse("sqrt(16) + sin(PI/2)")
        assertEquals(5.0, calc.eval(expr), 0.0001)

        // Test: 2 * PI * 5
        val expr2 = parser.parse("2 * PI * 5")
        assertEquals(10 * kotlin.math.PI, calc.eval(expr2), 0.0001)
    }

    @Test
    fun testParserErrors() {
        val parser = Parser()

        // Test empty expression
        assertThrows(ParseException::class.java) { parser.parse("") }

        // Test invalid character
        assertThrows(ParseException::class.java) { parser.parse("2 & 3") }

        // Test mismatched parentheses
        assertThrows(ParseException::class.java) { parser.parse("2 + (3 * 4") }
    }

    @Test
    fun testCalculatorDemo() {
        val parser = Parser()

        println("\n🧮 Advanced Calculator Demo")
        println("===========================")

        // Define test expressions with expected results
        val testExpressions =
                listOf(
                        "2 + 3" to 5.0,
                        "10 - 4" to 6.0,
                        "3 * 4" to 12.0,
                        "15 / 3" to 5.0,
                        "2^8" to 256.0,
                        "17 % 5" to 2.0,
                        "2 + 3 * 4" to 14.0,
                        "(2 + 3) * 4" to 20.0,
                        "sqrt(16)" to 4.0,
                        "abs(-42)" to 42.0,
                        "sin(PI/2)" to 1.0,
                        "cos(0)" to 1.0,
                        "ln(E)" to 1.0,
                        "log10(100)" to 2.0,
                        "sqrt(16) + sin(PI/2)" to 5.0,
                        "2 * PI * 5" to (2 * kotlin.math.PI * 5),
                        "-5 + 10" to 5.0,
                        "3^(1/2)" to kotlin.math.sqrt(3.0)
                )

        var passedTests = 0
        var totalTests = testExpressions.size

        for ((expression, expected) in testExpressions) {
            try {
                val expr = parser.parse(expression)
                val result = calc.eval(expr)
                val passed = kotlin.math.abs(result - expected) < 0.0001

                val status = if (passed) "✅ PASS" else "❌ FAIL"
                val formattedResult =
                        if (result == result.toLong().toDouble()) {
                            result.toLong().toString()
                        } else {
                            "%.6g".format(result)
                        }

                println("$status | $expression = $formattedResult")

                if (passed) {
                    passedTests++
                } else {
                    println("      Expected: $expected, Got: $result")
                }
            } catch (e: Exception) {
                println("❌ FAIL | $expression -> Error: ${e.message}")
            }
        }

        println("\nResults: $passedTests/$totalTests tests passed")

        if (passedTests == totalTests) {
            println("🎉 All tests passed! The calculator is working perfectly.")
        }

        // Assert that all tests passed
        assertEquals(totalTests, passedTests, "Not all calculator tests passed")

        println("\n📖 Calculator Features:")
        println("======================")
        println("✓ Basic arithmetic: +, -, *, /, ^, %")
        println("✓ Parentheses for grouping")
        println("✓ Unary operators: -, +")
        println("✓ Mathematical functions: sin, cos, tan, sqrt, ln, log10, abs")
        println("✓ Constants: PI, E")
        println("✓ Proper order of operations")
        println("✓ Error handling for invalid input")
        println("✓ Interactive CLI interface")
        println("\n🚀 To use the interactive calculator, run: ./gradlew run")
    }

    @Test
    fun testNewTrigonometricFunctions() {
        val parser = Parser()

        // Test cot(PI/4) = 1
        val cotExpr = parser.parse("cot(PI/4)")
        assertEquals(1.0, calc.eval(cotExpr), 0.0001)

        // Test sec(0) = 1
        val secExpr = parser.parse("sec(0)")
        assertEquals(1.0, calc.eval(secExpr), 0.0001)

        // Test asin(0.5) ≈ PI/6
        val asinExpr = parser.parse("asin(0.5)")
        assertEquals(kotlin.math.PI / 6, calc.eval(asinExpr), 0.0001)

        // Test acos(0.5) ≈ PI/3
        val acosExpr = parser.parse("acos(0.5)")
        assertEquals(kotlin.math.PI / 3, calc.eval(acosExpr), 0.0001)
    }

    @Test
    fun testHyperbolicFunctions() {
        val parser = Parser()

        // Test sinh(0) = 0
        val sinhExpr = parser.parse("sinh(0)")
        assertEquals(0.0, calc.eval(sinhExpr), 0.0001)

        // Test cosh(0) = 1
        val coshExpr = parser.parse("cosh(0)")
        assertEquals(1.0, calc.eval(coshExpr), 0.0001)

        // Test tanh(0) = 0
        val tanhExpr = parser.parse("tanh(0)")
        assertEquals(0.0, calc.eval(tanhExpr), 0.0001)

        // Test asinh(0) = 0
        val asinhExpr = parser.parse("asinh(0)")
        assertEquals(0.0, calc.eval(asinhExpr), 0.0001)
    }

    @Test
    fun testFactorialFunction() {
        val parser = Parser()

        // Test fact(5) = 120
        val factExpr = parser.parse("fact(5)")
        assertEquals(120.0, calc.eval(factExpr), 0.0001)

        // Test fact(0) = 1
        val fact0Expr = parser.parse("fact(0)")
        assertEquals(1.0, calc.eval(fact0Expr), 0.0001)

        // Test factorial alias
        val factorialExpr = parser.parse("factorial(4)")
        assertEquals(24.0, calc.eval(factorialExpr), 0.0001)
    }

    @Test
    fun testPrimeAndNumberTheoryFunctions() {
        val parser = Parser()

        // Test isprime(7) = 1 (true)
        val prime7Expr = parser.parse("isprime(7)")
        assertEquals(1.0, calc.eval(prime7Expr), 0.0001)

        // Test isprime(8) = 0 (false)
        val prime8Expr = parser.parse("isprime(8)")
        assertEquals(0.0, calc.eval(prime8Expr), 0.0001)

        // Test iseven(4) = 1 (true)
        val even4Expr = parser.parse("iseven(4)")
        assertEquals(1.0, calc.eval(even4Expr), 0.0001)

        // Test isodd(5) = 1 (true)
        val odd5Expr = parser.parse("isodd(5)")
        assertEquals(1.0, calc.eval(odd5Expr), 0.0001)

        // Test factors(6) = 4 (factors: 1, 2, 3, 6)
        val factors6Expr = parser.parse("factors(6)")
        assertEquals(4.0, calc.eval(factors6Expr), 0.0001)
    }

    @Test
    fun testRoundingFunctions() {
        val parser = Parser()

        // Test floor(3.7) = 3
        val floorExpr = parser.parse("floor(3.7)")
        assertEquals(3.0, calc.eval(floorExpr), 0.0001)

        // Test ceil(3.2) = 4
        val ceilExpr = parser.parse("ceil(3.2)")
        assertEquals(4.0, calc.eval(ceilExpr), 0.0001)

        // Test round(3.5) = 4
        val roundExpr = parser.parse("round(3.5)")
        assertEquals(4.0, calc.eval(roundExpr), 0.0001)

        // Test round(3.4) = 3
        val round2Expr = parser.parse("round(3.4)")
        assertEquals(3.0, calc.eval(round2Expr), 0.0001)
    }

    @Test
    fun testNewLogarithmicFunctions() {
        val parser = Parser()

        // Test log2(8) = 3
        val log2Expr = parser.parse("log2(8)")
        assertEquals(3.0, calc.eval(log2Expr), 0.0001)

        // Test exp(1) ≈ E
        val expExpr = parser.parse("exp(1)")
        assertEquals(kotlin.math.E, calc.eval(expExpr), 0.0001)

        // Test log1p(0) = 0
        val log1pExpr = parser.parse("log1p(0)")
        assertEquals(0.0, calc.eval(log1pExpr), 0.0001)
    }

    @Test
    fun testNewConstants() {
        val parser = Parser()

        // Test PHI (golden ratio)
        val phiExpr = parser.parse("PHI")
        assertEquals((1 + kotlin.math.sqrt(5.0)) / 2, calc.eval(phiExpr), 0.0001)

        // Test TAU = 2*PI
        val tauExpr = parser.parse("TAU")
        assertEquals(2 * kotlin.math.PI, calc.eval(tauExpr), 0.0001)

        // Test SQRT2
        val sqrt2Expr = parser.parse("SQRT2")
        assertEquals(kotlin.math.sqrt(2.0), calc.eval(sqrt2Expr), 0.0001)

        // Test LN2
        val ln2Expr = parser.parse("LN2")
        assertEquals(kotlin.math.ln(2.0), calc.eval(ln2Expr), 0.0001)
    }

    @Test
    fun testLogicalAndUtilityFunctions() {
        val parser = Parser()

        // Test not(0) = 1
        val notExpr = parser.parse("not(0)")
        assertEquals(1.0, calc.eval(notExpr), 0.0001)

        // Test not(5) = 0
        val not2Expr = parser.parse("not(5)")
        assertEquals(0.0, calc.eval(not2Expr), 0.0001)

        // Test sign(5) = 1
        val signPosExpr = parser.parse("sign(5)")
        assertEquals(1.0, calc.eval(signPosExpr), 0.0001)

        // Test sign(-3) = -1
        val signNegExpr = parser.parse("sign(-3)")
        assertEquals(-1.0, calc.eval(signNegExpr), 0.0001)

        // Test sign(0) = 0
        val signZeroExpr = parser.parse("sign(0)")
        assertEquals(0.0, calc.eval(signZeroExpr), 0.0001)
    }

    @Test
    @Suppress("UNUSED_VARIABLE")
    fun testBinaryOperations() {
        val parser = Parser()

        // Test min function
        val minExpr =
                parser.parse("5") // We'll need to extend this when we add proper min/max syntax
        // For now, these are binary operations that work with the existing structure

        // Test GCD
        // Note: This tests the internal binary operations, but we'd need to extend
        // the parser to handle functions with two arguments like gcd(12, 8)
    }

    @Test
    fun testAngleConversionFunctions() {
        val parser = Parser()

        // Test rads(90) = PI/2
        val rads90Expr = parser.parse("rads(90)")
        assertEquals(kotlin.math.PI / 2, calc.eval(rads90Expr), 0.0001)

        // Test rads(180) = PI
        val rads180Expr = parser.parse("rads(180)")
        assertEquals(kotlin.math.PI, calc.eval(rads180Expr), 0.0001)

        // Test degs(PI) = 180
        val degsPIExpr = parser.parse("degs(PI)")
        assertEquals(180.0, calc.eval(degsPIExpr), 0.0001)

        // Test degs(PI/2) = 90
        val degsPI2Expr = parser.parse("degs(PI/2)")
        assertEquals(90.0, calc.eval(degsPI2Expr), 0.0001)

        // Test round trip: degs(rads(45)) = 45
        val roundTripExpr = parser.parse("degs(rads(45))")
        assertEquals(45.0, calc.eval(roundTripExpr), 0.0001)

        // Test using conversion in trig functions: sin(rads(30)) = 0.5
        val sinRads30Expr = parser.parse("sin(rads(30))")
        assertEquals(0.5, calc.eval(sinRads30Expr), 0.0001)
    }

    @Test
    fun testComplexExpressions() {
        val parser = Parser()

        // Test combining new functions
        val complexExpr1 = parser.parse("fact(4) + log2(8)")
        assertEquals(27.0, calc.eval(complexExpr1), 0.0001) // 24 + 3

        // Test using new constants
        val complexExpr2 = parser.parse("PHI * TAU / 2")
        val expected = ((1 + kotlin.math.sqrt(5.0)) / 2) * (2 * kotlin.math.PI) / 2
        assertEquals(expected, calc.eval(complexExpr2), 0.0001)

        // Test hyperbolic and trig together
        val complexExpr3 = parser.parse("sinh(1) + sin(PI/2)")
        val expectedResult = kotlin.math.sinh(1.0) + 1.0
        assertEquals(expectedResult, calc.eval(complexExpr3), 0.0001)

        // Test angle conversions with other functions
        val complexExpr4 = parser.parse("cos(rads(60)) + sin(rads(30))")
        assertEquals(1.0, calc.eval(complexExpr4), 0.0001) // cos(60°) + sin(30°) = 0.5 + 0.5
    }
}
