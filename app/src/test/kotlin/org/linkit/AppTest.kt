/*
 * This source file was generated by the Gradle 'init' task
 */
@file:Suppress("UNRESOLVED_REFERENCE")

package org.linkit

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class AppTest {

    private val calc = Calc()

    @Test
    fun testBasicArithmetic() {
        // Test: 2 + 3
        val addExpr = Expr.BinaryOp(Expr.Number(2.0), Operation.Binary.Add, Expr.Number(3.0))
        assertEquals(5.0, calc.eval(addExpr), 0.0001)

        // Test: 10 - 4
        val subtractExpr =
                Expr.BinaryOp(Expr.Number(10.0), Operation.Binary.Subtract, Expr.Number(4.0))
        assertEquals(6.0, calc.eval(subtractExpr), 0.0001)

        // Test: 3 * 4
        val multiplyExpr =
                Expr.BinaryOp(Expr.Number(3.0), Operation.Binary.Multiply, Expr.Number(4.0))
        assertEquals(12.0, calc.eval(multiplyExpr), 0.0001)

        // Test: 8 / 2
        val divideExpr = Expr.BinaryOp(Expr.Number(8.0), Operation.Binary.Divide, Expr.Number(2.0))
        assertEquals(4.0, calc.eval(divideExpr), 0.0001)
    }

    @Test
    fun testOrderOfOperations() {
        // Test: 2 + 3 * 4 = 14 (not 20)
        val expr =
                Expr.BinaryOp(
                        Expr.Number(2.0),
                        Operation.Binary.Add,
                        Expr.BinaryOp(Expr.Number(3.0), Operation.Binary.Multiply, Expr.Number(4.0))
                )
        assertEquals(14.0, calc.eval(expr), 0.0001)
    }

    @Test
    fun testUnaryOperations() {
        // Test: sqrt(16)
        val sqrtExpr = Expr.UnaryOp(Operation.Unary.Sqrt, Expr.Number(16.0))
        assertEquals(4.0, calc.eval(sqrtExpr), 0.0001)

        // Test: -5
        val negateExpr = Expr.UnaryOp(Operation.Unary.Negate, Expr.Number(5.0))
        assertEquals(-5.0, calc.eval(negateExpr), 0.0001)

        // Test: abs(-3)
        val absExpr = Expr.UnaryOp(Operation.Unary.Abs, Expr.Number(-3.0))
        assertEquals(3.0, calc.eval(absExpr), 0.0001)
    }

    @Test
    fun testConstants() {
        // Test PI constant
        val piExpr = Expr.Variable("PI")
        assertEquals(kotlin.math.PI, calc.eval(piExpr), 0.0001)

        // Test E constant
        val eExpr = Expr.Variable("E")
        assertEquals(kotlin.math.E, calc.eval(eExpr), 0.0001)
    }

    @Test
    fun testTrigonometry() {
        // Test: sin(PI/2) = 1
        val sinExpr =
                Expr.UnaryOp(
                        Operation.Unary.Sin,
                        Expr.BinaryOp(
                                Expr.Variable("PI"),
                                Operation.Binary.Divide,
                                Expr.Number(2.0)
                        )
                )
        assertEquals(1.0, calc.eval(sinExpr), 0.0001)

        // Test: cos(0) = 1
        val cosExpr = Expr.UnaryOp(Operation.Unary.Cos, Expr.Number(0.0))
        assertEquals(1.0, calc.eval(cosExpr), 0.0001)
    }

    @Test
    fun testDivisionByZero() {
        val divideByZeroExpr =
                Expr.BinaryOp(Expr.Number(5.0), Operation.Binary.Divide, Expr.Number(0.0))

        val exception =
                assertThrows(ArithmeticException::class.java) { calc.eval(divideByZeroExpr) }
        assertEquals("Division by zero", exception.message)
    }

    @Test
    fun testSqrtOfNegative() {
        val sqrtNegativeExpr = Expr.UnaryOp(Operation.Unary.Sqrt, Expr.Number(-4.0))

        val exception =
                assertThrows(ArithmeticException::class.java) { calc.eval(sqrtNegativeExpr) }
        assertEquals("Square root of negative number", exception.message)
    }

    @Test
    fun testUnknownVariable() {
        val unknownVarExpr = Expr.Variable("UNKNOWN")

        val exception =
                assertThrows(IllegalArgumentException::class.java) { calc.eval(unknownVarExpr) }
        assertEquals("Unknown variable: UNKNOWN", exception.message)
    }

    @Test
    fun testParserBasicArithmetic() {
        val parser = Parser()

        // Test: 2 + 3
        val expr1 = parser.parse("2 + 3")
        assertEquals(5.0, calc.eval(expr1), 0.0001)

        // Test: 10 - 4
        val expr2 = parser.parse("10 - 4")
        assertEquals(6.0, calc.eval(expr2), 0.0001)

        // Test: 3 * 4
        val expr3 = parser.parse("3 * 4")
        assertEquals(12.0, calc.eval(expr3), 0.0001)

        // Test: 8 / 2
        val expr4 = parser.parse("8 / 2")
        assertEquals(4.0, calc.eval(expr4), 0.0001)
    }

    @Test
    fun testParserOrderOfOperations() {
        val parser = Parser()

        // Test: 2 + 3 * 4 = 14 (not 20)
        val expr = parser.parse("2 + 3 * 4")
        assertEquals(14.0, calc.eval(expr), 0.0001)

        // Test: (2 + 3) * 4 = 20
        val expr2 = parser.parse("(2 + 3) * 4")
        assertEquals(20.0, calc.eval(expr2), 0.0001)
    }

    @Test
    fun testParserFunctions() {
        val parser = Parser()

        // Test: sqrt(16)
        val expr1 = parser.parse("sqrt(16)")
        assertEquals(4.0, calc.eval(expr1), 0.0001)

        // Test: sin(PI/2)
        val expr2 = parser.parse("sin(PI/2)")
        assertEquals(1.0, calc.eval(expr2), 0.0001)

        // Test: abs(-5)
        val expr3 = parser.parse("abs(-5)")
        assertEquals(5.0, calc.eval(expr3), 0.0001)
    }

    @Test
    fun testParserComplexExpressions() {
        val parser = Parser()

        // Test: sqrt(16) + sin(PI/2)
        val expr = parser.parse("sqrt(16) + sin(PI/2)")
        assertEquals(5.0, calc.eval(expr), 0.0001)

        // Test: 2 * PI * 5
        val expr2 = parser.parse("2 * PI * 5")
        assertEquals(10 * kotlin.math.PI, calc.eval(expr2), 0.0001)
    }

    @Test
    fun testParserErrors() {
        val parser = Parser()

        // Test empty expression
        assertThrows(ParseException::class.java) { parser.parse("") }

        // Test invalid character
        assertThrows(ParseException::class.java) { parser.parse("2 & 3") }

        // Test mismatched parentheses
        assertThrows(ParseException::class.java) { parser.parse("2 + (3 * 4") }
    }

    @Test
    fun testCalculatorDemo() {
        val parser = Parser()

        println("\n🧮 Advanced Calculator Demo")
        println("===========================")

        // Define test expressions with expected results
        val testExpressions =
                listOf(
                        "2 + 3" to 5.0,
                        "10 - 4" to 6.0,
                        "3 * 4" to 12.0,
                        "15 / 3" to 5.0,
                        "2^8" to 256.0,
                        "17 % 5" to 2.0,
                        "2 + 3 * 4" to 14.0,
                        "(2 + 3) * 4" to 20.0,
                        "sqrt(16)" to 4.0,
                        "abs(-42)" to 42.0,
                        "sin(PI/2)" to 1.0,
                        "cos(0)" to 1.0,
                        "ln(E)" to 1.0,
                        "log10(100)" to 2.0,
                        "sqrt(16) + sin(PI/2)" to 5.0,
                        "2 * PI * 5" to (2 * kotlin.math.PI * 5),
                        "-5 + 10" to 5.0,
                        "3^(1/2)" to kotlin.math.sqrt(3.0)
                )

        var passedTests = 0
        var totalTests = testExpressions.size

        for ((expression, expected) in testExpressions) {
            try {
                val expr = parser.parse(expression)
                val result = calc.eval(expr)
                val passed = kotlin.math.abs(result - expected) < 0.0001

                val status = if (passed) "✅ PASS" else "❌ FAIL"
                val formattedResult =
                        if (result == result.toLong().toDouble()) {
                            result.toLong().toString()
                        } else {
                            "%.6g".format(result)
                        }

                println("$status | $expression = $formattedResult")

                if (passed) {
                    passedTests++
                } else {
                    println("      Expected: $expected, Got: $result")
                }
            } catch (e: Exception) {
                println("❌ FAIL | $expression -> Error: ${e.message}")
            }
        }

        println("\nResults: $passedTests/$totalTests tests passed")

        if (passedTests == totalTests) {
            println("🎉 All tests passed! The calculator is working perfectly.")
        }

        // Assert that all tests passed
        assertEquals(totalTests, passedTests, "Not all calculator tests passed")

        println("\n📖 Calculator Features:")
        println("======================")
        println("✓ Basic arithmetic: +, -, *, /, ^, %")
        println("✓ Parentheses for grouping")
        println("✓ Unary operators: -, +")
        println("✓ Mathematical functions: sin, cos, tan, sqrt, ln, log10, abs")
        println("✓ Constants: PI, E")
        println("✓ Proper order of operations")
        println("✓ Error handling for invalid input")
        println("✓ Interactive CLI interface")
        println("\n🚀 To use the interactive calculator, run: ./gradlew run")
    }
}
